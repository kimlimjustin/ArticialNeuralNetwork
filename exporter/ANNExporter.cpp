//-------------------------------------------------------------
//【文件名】ANNExporter.cpp
//【功能模块和目的】ANN格式神经网络模型导出器实现
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------

#include "ANNExporter.h"
#include "../model/ActivationFunction.h"
#include "../utils/FileUtils.h"
#include <iomanip>
#include <sstream>

//-------------------------------------------------------------
//【函数名称】ANNExporter
//【函数功能】构造函数
//【参数】无
//【返回值】无
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
ANNExporter::ANNExporter() {
}

//-------------------------------------------------------------
//【函数名称】~ANNExporter
//【函数功能】析构函数
//【参数】无
//【返回值】无
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
ANNExporter::~ANNExporter() {
}

//-------------------------------------------------------------
//【函数名称】exportNetwork
//【函数功能】导出神经网络到文件
//【参数】network：网络引用，filename：文件名
//【返回值】bool，是否导出成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::exportNetwork(const Network& network, const std::string& filename) {
    if (!isFormatSupported(filename)) {
        return false;
    }
    
    if (!validateNetworkForExport(network)) {
        return false;
    }
    
    std::ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    try {
        // Write file header
        writeComment(file, "ANN Neural Network File");
        writeComment(file, "Generated by ANN Exporter");
        file << std::endl;
        
        // Write network header
        if (!writeNetworkHeader(file, network)) {
            return false;
        }
        
        // Write layer information
        if (!writeLayerInformation(file, network)) {
            return false;
        }
        
        // Write connections
        if (!writeConnections(file, network)) {
            return false;
        }
        
        file.close();
        return true;
    }
    catch (const std::exception&) {
        return false;
    }
}

//-------------------------------------------------------------
//【函数名称】getSupportedExtensions
//【函数功能】获取支持的文件扩展名
//【参数】无
//【返回值】支持的文件扩展名字符串
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
std::string ANNExporter::getSupportedExtensions() const {
    return ".ann";
}

//-------------------------------------------------------------
//【函数名称】getExporterName
//【函数功能】获取导出器名称
//【参数】无
//【返回值】导出器名称字符串
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
std::string ANNExporter::getExporterName() const {
    return "ANN Exporter";
}

//-------------------------------------------------------------
//【函数名称】writeNetworkHeader
//【函数功能】写入网络头信息
//【参数】file：文件流，network：网络引用
//【返回值】bool，是否写入成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::writeNetworkHeader(std::ofstream& file, const Network& network) {
    writeComment(file, network.getName());
    file << "G " << network.getName() << std::endl;
    return file.good();
}

//-------------------------------------------------------------
//【函数名称】writeLayerInformation
//【函数功能】写入层信息
//【参数】file：文件流，network：网络引用
//【返回值】bool，是否写入成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::writeLayerInformation(std::ofstream& file, const Network& network) {
    writeComment(file, "Six Neurons: zero bias, without activation function");
    
    // First, write all neurons
    int neuronIndex = 0;
    for (int i = 0; i < network.getLayerCount(); ++i) {
        const Layer* layer = network.getLayer(i);
        if (!layer) {
            return false;
        }
        
        for (int j = 0; j < layer->getNeuronCount(); ++j) {
            const Neuron* neuron = layer->getNeuron(j);
            if (!neuron) {
                return false;
            }
            
            // Write neuron: N bias activation_type
            file << "N " << std::fixed << std::setprecision(1) << neuron->getBias() << " ";
            
            // Determine activation type (0 for linear/no activation)
            const ActivationFunction* activationFunc = neuron->getActivationFunction();
            int activationType = 0; // Default to linear
            if (activationFunc && activationFunc->getName() != "Linear") {
                // For now, map all non-linear to type 1, can be extended
                activationType = 1;
            }
            file << activationType << std::endl;
            
            neuronIndex++;
        }
    }
    
    // Then, write layer definitions
    neuronIndex = 0;
    for (int i = 0; i < network.getLayerCount(); ++i) {
        const Layer* layer = network.getLayer(i);
        if (!layer) {
            return false;
        }
        
        writeComment(file, "Layer " + std::to_string(i) + ": Neuron " + 
                    std::to_string(neuronIndex) + " to " + 
                    std::to_string(neuronIndex + layer->getNeuronCount() - 1));
        
        int startNeuron = neuronIndex;
        int endNeuron = neuronIndex + layer->getNeuronCount() - 1;
        file << "L " << startNeuron << " " << endNeuron << std::endl;
        
        neuronIndex += layer->getNeuronCount();
    }
    
    return file.good();
}

//-------------------------------------------------------------
//【函数名称】writeNeuronInformation
//【函数功能】写入神经元信息
//【参数】file：文件流，layer：层引用
//【返回值】bool，是否写入成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::writeNeuronInformation(std::ofstream& file, const Layer& layer) {
    for (int i = 0; i < layer.getNeuronCount(); ++i) {
        const Neuron* neuron = layer.getNeuron(i);
        if (!neuron) {
            return false;
        }
        
        file << "NEURON " << std::fixed << std::setprecision(6) << neuron->getBias();
        
        const ActivationFunction* activationFunc = neuron->getActivationFunction();
        if (activationFunc) {
            file << " ACTIVATION " << getActivationFunctionName(activationFunc);
        }
        
        file << std::endl;
    }
    
    return file.good();
}

//-------------------------------------------------------------
//【函数名称】writeConnections
//【函数功能】写入连接信息
//【参数】file：文件流，network：网络引用
//【返回值】bool，是否写入成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::writeConnections(std::ofstream& file, const Network& network) {
    // First write input connections (from external input to first layer)
    const Layer* firstLayer = network.getLayer(0);
    if (firstLayer) {
        writeComment(file, "Neuron 0 to " + std::to_string(firstLayer->getNeuronCount() - 1) + ": has one Dendrite");
        for (int i = 0; i < firstLayer->getNeuronCount(); ++i) {
            file << "S -1 " << i << " 1.0" << std::endl;
        }
    }
    
    // Write output connections (from last layer to external output)
    const Layer* lastLayer = network.getLayer(network.getLayerCount() - 1);
    if (lastLayer) {
        int lastLayerStart = 0;
        for (int i = 0; i < network.getLayerCount() - 1; ++i) {
            const Layer* layer = network.getLayer(i);
            if (layer) {
                lastLayerStart += layer->getNeuronCount();
            }
        }
        
        writeComment(file, "Neuron " + std::to_string(lastLayerStart) + " to " + 
                    std::to_string(lastLayerStart + lastLayer->getNeuronCount() - 1) + ": has one Axon");
        for (int i = 0; i < lastLayer->getNeuronCount(); ++i) {
            file << "S " << (lastLayerStart + i) << " -1 1.0" << std::endl;
        }
    }
    
    // Write inter-layer connections
    int currentNeuronOffset = 0;
    for (int layerIndex = 0; layerIndex < network.getLayerCount(); ++layerIndex) {
        const Layer* layer = network.getLayer(layerIndex);
        if (!layer) continue;
        
        for (int neuronIndex = 0; neuronIndex < layer->getNeuronCount(); ++neuronIndex) {
            const Neuron* neuron = layer->getNeuron(neuronIndex);
            if (!neuron) continue;
            
            int globalNeuronIndex = currentNeuronOffset + neuronIndex;
            
            // Write output connections for this neuron
            if (neuron->getOutputSynapseCount() > 0) {
                // Find target layer neurons
                int targetLayerStart = currentNeuronOffset + layer->getNeuronCount();
                
                // Add comment for this neuron's connections if it's not the last layer
                if (layerIndex < network.getLayerCount() - 1) {
                    const Layer* nextLayer = network.getLayer(layerIndex + 1);
                    if (nextLayer) {
                        writeComment(file, "Dendrites from Neuron " + std::to_string(globalNeuronIndex) + 
                                    " to Neuron " + std::to_string(targetLayerStart) + "~" + 
                                    std::to_string(targetLayerStart + nextLayer->getNeuronCount() - 1));
                    }
                }
                
                for (int synapseIndex = 0; synapseIndex < neuron->getOutputSynapseCount(); ++synapseIndex) {
                    const Synapse* synapse = neuron->getOutputSynapse(synapseIndex);
                    if (!synapse) continue;
                    
                    const Neuron* targetNeuron = synapse->getTargetNeuron();
                    if (!targetNeuron) continue;
                    
                    // Find the global index of the target neuron
                    int targetGlobalIndex = findNeuronGlobalIndex(network, targetNeuron);
                    if (targetGlobalIndex >= 0) {
                        file << "S " << globalNeuronIndex << " " << targetGlobalIndex 
                             << " " << std::fixed << std::setprecision(4) << synapse->getWeight() 
                             << std::endl;
                    }
                }
            }
        }
        
        currentNeuronOffset += layer->getNeuronCount();
    }
    
    return file.good();
}

//-------------------------------------------------------------
//【函数名称】writeComment
//【函数功能】写入注释
//【参数】file：文件流，comment：注释内容
//【返回值】无
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
void ANNExporter::writeComment(std::ofstream& file, const std::string& comment) {
    file << "# " << comment << std::endl;
}

//-------------------------------------------------------------
//【函数名称】getActivationFunctionName
//【函数功能】获取激活函数名称
//【参数】activationFunction：激活函数指针
//【返回值】激活函数名称字符串
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
std::string ANNExporter::getActivationFunctionName(const ActivationFunction* activationFunction) {
    if (!activationFunction) {
        return "Linear";
    }
    return activationFunction->getName();
}

//-------------------------------------------------------------
//【函数名称】findNeuronGlobalIndex
//【函数功能】查找神经元的全局索引
//【参数】network：网络引用，targetNeuron：目标神经元指针
//【返回值】int，全局索引，未找到返回-1
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
int ANNExporter::findNeuronGlobalIndex(const Network& network, const Neuron* targetNeuron) {
    int globalIndex = 0;
    
    for (int layerIndex = 0; layerIndex < network.getLayerCount(); ++layerIndex) {
        const Layer* layer = network.getLayer(layerIndex);
        if (!layer) continue;
        
        for (int neuronIndex = 0; neuronIndex < layer->getNeuronCount(); ++neuronIndex) {
            if (layer->getNeuron(neuronIndex) == targetNeuron) {
                return globalIndex;
            }
            globalIndex++;
        }
    }
    
    return -1; // Not found
}
