//-------------------------------------------------------------
//【文件名】ANNExporter.cpp
//【功能模块和目的】ANN格式神经网络模型导出器实现
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------

#include "ANNExporter.hpp"
#include "../model/activation_functions/ActivationFunction.hpp"
#include "../utils/FileUtils.hpp"
#include <iomanip>
#include <sstream>

using namespace std;

//-------------------------------------------------------------
//【函数名称】ANNExporter
//【函数功能】构造函数
//【参数】无
//【返回值】无
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
ANNExporter::ANNExporter() {
}

//-------------------------------------------------------------
//【函数名称】~ANNExporter
//【函数功能】析构函数
//【参数】无
//【返回值】无
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
ANNExporter::~ANNExporter() = default;

//-------------------------------------------------------------
//【函数名称】exportNetwork
//【函数功能】导出神经网络到文件
//【参数】network：网络引用，filename：文件名
//【返回值】bool，是否导出成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::exportNetwork(const Network& network, const string& filename) {
    if (!isFormatSupported(filename)) {
        return false;
    }
    
    if (!validateNetworkForExport(network)) {
        return false;
    }
    
    ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    try {
        // Write file header
        writeComment(file, "ANN Neural Network File");
        writeComment(file, "Generated by ANN Exporter");
        file << endl;
        
        // Write network header
        if (!writeNetworkHeader(file, network)) {
            return false;
        }
        
        // Write layer information
        if (!writeLayerInformation(file, network)) {
            return false;
        }
        
        // Write connections
        if (!writeConnections(file, network)) {
            return false;
        }
        
        file.close();
        return true;
    }
    catch (const exception&) {
        return false;
    }
}

//-------------------------------------------------------------
//【函数名称】getSupportedExtensions
//【函数功能】获取支持的文件扩展名
//【参数】无
//【返回值】支持的文件扩展名字符串
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
string ANNExporter::getSupportedExtensions() const {
    return ".ann";
}

//-------------------------------------------------------------
//【函数名称】getExporterName
//【函数功能】获取导出器名称
//【参数】无
//【返回值】导出器名称字符串
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
string ANNExporter::getExporterName() const {
    return "ANN Exporter";
}

//-------------------------------------------------------------
//【函数名称】writeNetworkHeader
//【函数功能】写入网络头信息
//【参数】file：文件流，network：网络引用
//【返回值】bool，是否写入成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::writeNetworkHeader(ofstream& file, const Network& network) {
    writeComment(file, network.getName());
    file << "G " << network.getName() << endl;
    return file.good();
}

//-------------------------------------------------------------
//【函数名称】writeLayerInformation
//【函数功能】写入层信息
//【参数】file：文件流，network：网络引用
//【返回值】bool，是否写入成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::writeLayerInformation(ofstream& file, const Network& network) {
    writeComment(file, "Six Neurons: zero bias, without activation function");
    
    // First, write all neurons
    int neuronIndex = 0;
    for (int i = 0; i < network.getLayerCount(); ++i) {
        const Layer* layer = network.getLayer(i);
        if (!layer) {
            return false;
        }
        
        for (int j = 0; j < layer->getNeuronCount(); ++j) {
            const Neuron* neuron = layer->getNeuron(j);
            if (!neuron) {
                return false;
            }
            
            // Write neuron: N bias activation_type
            file << "N " << fixed << setprecision(1) << neuron->getBias() << " ";
            
            // Determine activation type based on function name
            const ActivationFunction* activationFunc = neuron->getActivationFunction();
            int activationType = 0; // Default to linear
            if (activationFunc) {
                string name = activationFunc->getName();
                if (name == "Linear") {
                    activationType = 0;
                } else if (name == "Sigmoid") {
                    activationType = 1;
                } else if (name == "Tanh") {
                    activationType = 2;
                } else if (name == "ReLU") {
                    activationType = 3;
                } else {
                    activationType = 0; // Default to linear for unknown types
                }
            }
            file << activationType << endl;
            
            neuronIndex++;
        }
    }
    
    // Then, write layer definitions
    neuronIndex = 0;
    for (int i = 0; i < network.getLayerCount(); ++i) {
        const Layer* layer = network.getLayer(i);
        if (!layer) {
            return false;
        }
        
        writeComment(file, "Layer " + to_string(i) + ": Neuron " + 
                    to_string(neuronIndex) + " to " + 
                    to_string(neuronIndex + layer->getNeuronCount() - 1));
        
        int startNeuron = neuronIndex;
        int endNeuron = neuronIndex + layer->getNeuronCount() - 1;
        file << "L " << startNeuron << " " << endNeuron << endl;
        
        neuronIndex += layer->getNeuronCount();
    }
    
    return file.good();
}

//-------------------------------------------------------------
//【函数名称】writeNeuronInformation
//【函数功能】写入神经元信息
//【参数】file：文件流，layer：层引用
//【返回值】bool，是否写入成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::writeNeuronInformation(ofstream& file, const Layer& layer) {
    for (int i = 0; i < layer.getNeuronCount(); ++i) {
        const Neuron* neuron = layer.getNeuron(i);
        if (!neuron) {
            return false;
        }
        
        file << "NEURON " << fixed << setprecision(6) << neuron->getBias();
        
        const ActivationFunction* activationFunc = neuron->getActivationFunction();
        if (activationFunc) {
            file << " ACTIVATION " << getActivationFunctionName(activationFunc);
        }
        
        file << endl;
    }
    
    return file.good();
}

//-------------------------------------------------------------
//【函数名称】writeConnections
//【函数功能】写入连接信息
//【参数】file：文件流，network：网络引用
//【返回值】bool，是否写入成功
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
bool ANNExporter::writeConnections(ofstream& file, const Network& network) {
    // First write input connections (from external input to first layer)
    const Layer* firstLayer = network.getLayer(0);
    if (firstLayer) {
        writeComment(file, "Neuron 0 to " + to_string(firstLayer->getNeuronCount() - 1) + ": has one Dendrite");
        for (int i = 0; i < firstLayer->getNeuronCount(); ++i) {
            const Neuron* neuron = firstLayer->getNeuron(i);
            if (neuron && neuron->getInputSynapseCount() > 0) {
                // Find the input synapse with source = nullptr (external input)
                for (int j = 0; j < neuron->getInputSynapseCount(); ++j) {
                    const Synapse* synapse = neuron->getInputSynapse(j);
                    if (synapse && synapse->getSourceNeuron() == nullptr) {
                        file << "S -1 " << i << " " << fixed << setprecision(1) 
                             << synapse->getWeight() << endl;
                        break;
                    }
                }
            }
        }
    }
    
    // Write output connections (from last layer to external output)
    const Layer* lastLayer = network.getLayer(network.getLayerCount() - 1);
    if (lastLayer) {
        int lastLayerStart = 0;
        for (int i = 0; i < network.getLayerCount() - 1; ++i) {
            const Layer* layer = network.getLayer(i);
            if (layer) {
                lastLayerStart += layer->getNeuronCount();
            }
        }
        
        writeComment(file, "Neuron " + to_string(lastLayerStart) + " to " + 
                    to_string(lastLayerStart + lastLayer->getNeuronCount() - 1) + ": has one Axon");
        for (int i = 0; i < lastLayer->getNeuronCount(); ++i) {
            const Neuron* neuron = lastLayer->getNeuron(i);
            if (neuron && neuron->getOutputSynapseCount() > 0) {
                // Find the output synapse with target = nullptr (external output)
                for (int j = 0; j < neuron->getOutputSynapseCount(); ++j) {
                    const Synapse* synapse = neuron->getOutputSynapse(j);
                    if (synapse && synapse->getTargetNeuron() == nullptr) {
                        file << "S " << (lastLayerStart + i) << " -1 " << fixed << setprecision(1) 
                             << synapse->getWeight() << endl;
                        break;
                    }
                }
            }
        }
    }
    
    // Write inter-layer connections
    int currentNeuronOffset = 0;
    for (int layerIndex = 0; layerIndex < network.getLayerCount(); ++layerIndex) {
        const Layer* layer = network.getLayer(layerIndex);
        if (!layer) continue;
        
        for (int neuronIndex = 0; neuronIndex < layer->getNeuronCount(); ++neuronIndex) {
            const Neuron* neuron = layer->getNeuron(neuronIndex);
            if (!neuron) continue;
            
            int globalNeuronIndex = currentNeuronOffset + neuronIndex;
            
            // Write output connections for this neuron
            if (neuron->getOutputSynapseCount() > 0) {
                // Find target layer neurons
                int targetLayerStart = currentNeuronOffset + layer->getNeuronCount();
                
                // Add comment for this neuron's connections if it's not the last layer
                if (layerIndex < network.getLayerCount() - 1) {
                    const Layer* nextLayer = network.getLayer(layerIndex + 1);
                    if (nextLayer) {
                        writeComment(file, "Dendrites from Neuron " + to_string(globalNeuronIndex) + 
                                    " to Neuron " + to_string(targetLayerStart) + "~" + 
                                    to_string(targetLayerStart + nextLayer->getNeuronCount() - 1));
                    }
                }
                
                for (int synapseIndex = 0; synapseIndex < neuron->getOutputSynapseCount(); ++synapseIndex) {
                    const Synapse* synapse = neuron->getOutputSynapse(synapseIndex);
                    if (!synapse) continue;
                    
                    const Neuron* targetNeuron = synapse->getTargetNeuron();
                    if (!targetNeuron) continue;
                    
                    // Find the global index of the target neuron
                    int targetGlobalIndex = findNeuronGlobalIndex(network, targetNeuron);
                    if (targetGlobalIndex >= 0) {
                        // 根据规范：轴突权重恒为1.0，实际连接权重存储在目标神经元的树突中
                        // 找到目标神经元中对应的输入突触（树突）来获取实际权重
                        double connectionWeight = 1.0; // 默认权重
                        for (int inputIdx = 0; inputIdx < targetNeuron->getInputSynapseCount(); ++inputIdx) {
                            const Synapse* inputSynapse = targetNeuron->getInputSynapse(inputIdx);
                            if (inputSynapse && inputSynapse->getSourceNeuron() == neuron) {
                                connectionWeight = inputSynapse->getWeight();
                                break;
                            }
                        }
                        
                        file << "S " << globalNeuronIndex << " " << targetGlobalIndex 
                             << " " << fixed << setprecision(4) << connectionWeight 
                             << endl;
                    }
                }
            }
        }
        
        currentNeuronOffset += layer->getNeuronCount();
    }
    
    return file.good();
}

//-------------------------------------------------------------
//【函数名称】writeComment
//【函数功能】写入注释
//【参数】file：文件流，comment：注释内容
//【返回值】无
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
void ANNExporter::writeComment(ofstream& file, const string& comment) {
    file << "# " << comment << endl;
}

//-------------------------------------------------------------
//【函数名称】getActivationFunctionName
//【函数功能】获取激活函数名称
//【参数】activationFunction：激活函数指针
//【返回值】激活函数名称字符串
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
string ANNExporter::getActivationFunctionName(const ActivationFunction* activationFunction) const {
    if (!activationFunction) {
        return "Linear";
    }
    return activationFunction->getName();
}

//-------------------------------------------------------------
//【函数名称】findNeuronGlobalIndex
//【函数功能】查找神经元的全局索引
//【参数】network：网络引用，targetNeuron：目标神经元指针
//【返回值】int，全局索引，未找到返回-1
//【开发者及日期】林钲凯 2025-07-27
//【更改记录】
//-------------------------------------------------------------
int ANNExporter::findNeuronGlobalIndex(const Network& network, const Neuron* targetNeuron) {
    int globalIndex = 0;
    
    for (int layerIndex = 0; layerIndex < network.getLayerCount(); ++layerIndex) {
        const Layer* layer = network.getLayer(layerIndex);
        if (!layer) continue;
        
        for (int neuronIndex = 0; neuronIndex < layer->getNeuronCount(); ++neuronIndex) {
            if (layer->getNeuron(neuronIndex) == targetNeuron) {
                return globalIndex;
            }
            globalIndex++;
        }
    }
    
    return -1; // Not found
}
